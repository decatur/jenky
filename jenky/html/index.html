<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Jenky</title>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            margin: 2em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        table, td, th {
            border: 1px solid black;
        }

        td, th {
            padding: 1ex;
        }

        tbody tr:hover {
          background-color: #ffff99;
        }

        fieldset {
            margin-top: 1em;
        }

        .grid-container {
            margin-top: 1ex;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 0 1em;
        }

    </style>
</head>
<body>
<div>
    <h1 id="appName" style="display: inline-block"></h1><a href="/docs">OpenAPI Spec</a>
</div>
<table>
    <thead>
    <tr>
        <th>Repo Name</th>
        <th>Git Ref</th>
        <th>Process Name</th>
        <th>Start Time</th>
        <th>Keep Alive</th>
        <th>Logs</th>
    </tr>
    </thead>
    <tbody id="repos"></tbody>
</table>

<template id="processRow">
    <tr>
        <td>Repo Name</td>
        <!--<td><label><input type="radio" name="process"></label></td>-->
        <td>Git Ref</td>
        <td>Process Name</td>
        <td>Start Time</td>
        <td>
            <label style="display: inline-block"><input type="checkbox" name="KeepAlive"></label>
        </td>
        <td>
            <a href="" target="">out</a>
            <a href="" target="">log</a>
            <a href="" target="">log.1</a>
        </td>
    </tr>
</template>

<pre id="logs">
</pre>

</body>
<script type="module">
    /** @type{jenky.Repo[]} */
    let repos;
    /** @type{Object.<string, jenky.Repo>} */
    let reposByName ={};

    class ConcernedFaceIterator {
        constructor() {
            this.faces = [];
            for (const face of "ðŸ˜•ðŸ˜ŸðŸ˜¯ðŸ˜²ðŸ˜³ðŸ¥ºðŸ˜¦ðŸ˜§ðŸ˜¨ðŸ˜°ðŸ˜¥ðŸ˜¢ðŸ˜­ðŸ˜±ðŸ˜–ðŸ˜£ðŸ˜žðŸ˜¤ðŸ˜¡â˜ ") this.faces.push(face);
        }

        next() {
            const face = this.faces.shift();
            this.faces.push(face);
            return face;
        }
    }

    const concernedFaceIterator = new ConcernedFaceIterator();

    /**
     */
    function renderRepos() {
        const tbody = document.getElementById('repos');
        tbody.textContent = '';
        const template = document.getElementById('processRow');
        for (const repo of repos) {
            const name = repo.repoName;
            for (const [index, proc] of repo.processes.entries()) {
                let tr = template.content.firstElementChild.cloneNode(true);
                let td = tr.firstElementChild;
                if (repo.remoteUrl) {
                    td.textContent = '';
                    const a = document.createElement('a');
                    a.href = repo.remoteUrl;
                    a.textContent = repo.repoName;
                    td.appendChild(a);
                } else {
                    td.textContent = repo.repoName;
                }

                td = td.nextElementSibling;
                td.textContent = repo.gitRef; //firstElementChild.value = repo.repoName;
                    // td.firstElementChild.addEventListener('change', () => {
                    //     fetchRepo(name)
                    //         .then(repo => {
                    //             reposByName[name] = repo;
                    //             renderRepo(name);
                    //         })
                    // });

                td = td.nextElementSibling;
                if (proc.serviceSubDomain) {
                    td.textContent = '';
                    const a = document.createElement('a');
                    const domains = location.hostname.split('.');
                    domains[0] = proc.serviceSubDomain;
                    a.href = location.protocol + '//' + domains.join('.') + (proc.serviceHomePath || '');
                    a.textContent = proc.name;
                    td.appendChild(a);
                } else {
                    td.textContent = proc.name;
                }

                td = td.nextElementSibling;
                td.textContent = proc.createTime ? new Date(proc.createTime * 1000).toISOString() : '';

                td = td.nextElementSibling;   // Status
                const input = td.querySelector('input');
                input.checked = proc.keepRunning;
                input.addEventListener('change', (evt) => {
                    // evt.target.disabled = true;
                    changeProcessState(repo, proc, input.checked?'restart':'kill');
                });

                td = td.nextElementSibling;
                let a = td.firstElementChild;
                while (a) {
                    const logType = a.textContent;
                    a.href = `/repos/${name}/processes/${proc.name}/${logType}`;
                    a.target = `${proc.name}_${logType}`;
                    a = a.nextElementSibling;
                }

                tbody.appendChild(tr);
            }
        }
    }

    /**
     * @param {jenky.Repo[]} data
     */
    function setRepos(data) {
        repos = data;
        reposByName = {};
        for (const repo of repos) {
            reposByName[repo.repoName] = repo;
        }
    }

    /**
     * @param {jenky.Repo} repo
     * @param {jenky.Process} proc
     * @param {string} action
     */
    function changeProcessState(repo, proc, action) {
        const payload = {action: action};
        fetch(`/repos/${repo.repoName}/processes/${proc.name}`, {method: 'post', body: JSON.stringify(payload)})
            .then(response => {
                if (response.status === 200) {
                    return response.json();
                } else {
                    console.log(response.statusText + ' ' + response.url);
                    response.text().then(text => alert(text))
                }
            })
            .then(data => console.log(data))
            .then(fetchLogs)
    }

    function fetchRepos() {
        fetchLogs()
        fetch('/repos')
            .then(response => response.json())
            .then(data => {
                document.getElementById('appName').textContent = data['appName'];
                setRepos(data['repos']);
                renderRepos();
            })
    }

    let logs = [];
    function fetchLogs() {
        const params = new URLSearchParams();
        if (logs.length) {
            params.append('last_event_id', String(logs[0][0]));
        }
        fetch('/logs?' + params.toString())
            .then(response => response.json())
            .then(data => {
                logs = data['logsSince'].concat(logs).slice(0, data['maxLength']);
                document.getElementById('logs').textContent = JSON.stringify(logs.map(item => item[1]), null, 4);
            })
    }

    fetchRepos()
    fetchLogs()
</script>
</html>
